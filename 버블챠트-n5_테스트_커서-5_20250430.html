<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>25년 상반기 유형별 절감 대시보드 (1월~5월)</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body { 
      font-family: 'Noto Sans KR', sans-serif; 
      margin: 0; 
      padding: 20px; 
      background: #f0f2f5;
      position: relative;
      min-height: 100vh;
    }
    h1 { 
      text-align: center; 
      color: #1a237e; 
      font-size: 32px; 
      margin-bottom: 2px; 
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #f0f2f5;
      padding: 15px;
      z-index: 1000;
      font-weight: 700;
      letter-spacing: 0.5px;
      border-bottom: 2px solid #1a237e;
    }
    #controls { 
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 1000;
      background: white;
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      max-width: 150px;
    }
    #controls input[type="file"] { 
      margin: 0; 
      padding: 4px 8px; 
      border: none; 
      border-radius: 4px; 
      background: #f8f9fa; 
      color: #666; 
      cursor: pointer; 
      font-size: 9px;
      transition: all 0.3s ease;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      width: 100%;
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
    }
    #controls input[type="file"]:hover {
      background: #e9ecef;
    }
    #message {
      position: fixed;
      top: 50px;
      left: 20px;
      color: #888;
      font-size: 9px;
      font-style: italic;
      z-index: 1000;
      background: white;
      padding: 4px 8px;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      max-width: 150px;
    }
    #dashboard-container { 
      display: flex; 
      justify-content: flex-start; 
      align-items: flex-start; 
      gap: 10px;
      padding: 10px;
      flex-wrap: nowrap;
      position: relative;
      width: 100%;
      box-sizing: border-box;
      min-height: calc(100vh - 100px);
      overflow: visible;
      margin-top: 150px;
    }
    #chart { 
      width: 40%;
      max-width: none;
      height: calc(100vh - 120px);
      aspect-ratio: 1;
      flex-shrink: 0;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      overflow: visible;
      margin-left: 0;
      padding-left: 0;
    }
    svg {
      overflow: visible;
    }
    .node { 
      transform-style: preserve-3d;
      transition: opacity 0.3s ease, filter 0.3s ease;
      cursor: pointer;
      will-change: opacity, filter;
    }
    .node:hover {
      opacity: 0.9;
    }
    .node circle {
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
      transition: all 0.3s ease;
      will-change: filter, stroke-width;
    }
    .node.selected circle {
      filter: drop-shadow(0 8px 16px rgba(0,0,0,0.3));
      stroke-width: 4;
      opacity: 1 !important;
    }
    .node:not(.selected) circle {
      opacity: 0.3;
      stroke: #cccccc;
    }
    .node text { 
      text-anchor: middle; 
      dominant-baseline: middle; 
      pointer-events: none;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
    }
    .node.selected text {
      font-weight: bold;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
      opacity: 1;
    }
    .node:not(.selected) text {
      opacity: 0.3;
    }
    #table-container { 
      width: 60%;
      background: white; 
      padding: 15px; 
      border-radius: 8px; 
      box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
      font-size: 13px; 
      height: calc(100vh - 200px);
      overflow: auto;
      position: fixed;
      right: 0;
      top: 150px;
      flex-shrink: 0;
    }
    table { 
      border-collapse: separate; 
      border-spacing: 0;
      width: 100%;
      table-layout: auto;
      position: relative;
    }
    thead { 
      position: sticky;
      top: 0;
      z-index: 2;
      background: white;
    }
    thead th { 
      background: #f8f9fa; 
      font-size: 13px; 
      padding: 6px;
      border-bottom: 2px solid #dee2e6;
      white-space: normal;
    }
    th, td { 
      padding: 6px; 
      border: 1px solid #dee2e6; 
      text-align: center; 
      font-size: 13px; 
      word-wrap: break-word;
      white-space: normal;
      overflow: hidden;
      max-width: 300px;
    }
    th:nth-child(1), td:nth-child(1) { width: 7%; }  /* 월 */
    th:nth-child(2), td:nth-child(2) { width: 10%; } /* 작업유형 */
    th:nth-child(3), td:nth-child(3) { width: 18%; } /* 절감항목 */
    th:nth-child(4), td:nth-child(4) { width: 10%; } /* A.집행비 */
    th:nth-child(5), td:nth-child(5) { width: 10%; } /* B.공사비 적용시 */
    th:nth-child(6), td:nth-child(6) { width: 10%; } /* 절감비(A-B) */
    th:nth-child(7), td:nth-child(7) { width: 35%; } /* 비고 - 더 넓게 설정 */
    tr.group-header td { 
      background: #f8f9fa; 
      font-weight: bold; 
      text-align: left; 
    }
    tr.subtotal td { 
      font-weight: bold; 
      background: #e3f2fd; 
      color: #1976d2; 
    }
    tr:hover td {
      background: #f8f9fa;
    }
    .month-checkbox {
      display: flex;
      align-items: center;
      padding: 4px 8px;
      background: transparent;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 12px;
      color: #999;
    }
    .month-checkbox:hover {
      background: #e9ecef;
    }
    .month-checkbox input[type="checkbox"] {
      display: none;
    }
    .month-checkbox.selected {
      background: #e3f2fd;
      color: #1976d2;
    }
    .month-checkbox.selected::before {
      content: "✓";
      margin-right: 5px;
      color: #1976d2;
    }
    #select-all-container {
      text-align: center;
      margin: 0;
      padding: 3px;
      background: white;
      border-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      width: 120px;
      position: fixed;
      top: 100px;
      left: 20px;
      z-index: 1000;
    }
    #select-all-checkbox {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 3px;
      cursor: pointer;
      padding: 2px 4px;
      font-size: 11px;
      color: #666;
      transition: all 0.2s ease;
    }
    #select-all-checkbox:hover {
      background: #f8f9fa;
      border-radius: 4px;
    }
    #select-all-checkbox input {
      margin: 0;
      width: 12px;
      height: 12px;
    }
    #month-filter-container {
      text-align: center;
      margin: 0 auto 10px;
      padding: 0;
      max-width: 80%;
      position: fixed;
      top: 100px;
      left: 180px;
      right: 0;
      z-index: 1000;
      background: #f0f2f5;
      padding: 5px 0;
    }
    #month-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      justify-content: center;
    }
    @media (max-width: 1400px) {
      #chart {
        width: 35%;
      }
      #table-container {
        width: 65%;
        font-size: 12px;
        top: 150px;
      }
      thead th {
        top: 150px;
      }
      th, td {
        padding: 4px;
        font-size: 12px;
      }
      #select-all-container {
        top: 120px;
        left: 20px;
      }
      #month-filter-container {
        top: 120px;
        left: 180px;
      }
    }
    @media (max-width: 1200px) {
      #dashboard-container {
        flex-wrap: wrap;
        justify-content: center;
        margin-top: 200px;
      }
      #chart {
        width: 100%;
        max-width: 700px;
        justify-content: center;
      }
      #table-container {
        width: 100%;
        max-width: 900px;
        position: static;
        margin-top: 20px;
        height: auto;
      }
      thead th {
        position: static;
      }
      #select-all-container {
        position: fixed;
        top: 120px;
        left: 20px;
        margin: 0;
      }
      #month-filter-container {
        position: fixed;
        top: 120px;
        left: 180px;
        margin: 0;
      }
    }
    .sticky-total-row { 
      position: sticky; 
      top: 40px; 
      background: #fff5f5; 
      z-index: 2; 
    }
    .sticky-total-row td { 
      font-weight: bold; 
      color: #e74c3c; 
    }
    tbody tr:not(.sticky-total-row) {
      position: relative;
      z-index: 1;
    }
    /* 비고 열의 텍스트 스타일 */
    td:nth-child(7) {
      font-size: 12px;
      text-align: center;
      padding-left: 10px;
      white-space: normal;
      word-break: break-word;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    /* 버블 선택 시 비고 열 스타일 변경 */
    .node.selected ~ #table-container td:nth-child(7) {
      font-size: 11px;
      line-height: 1.3;
    }
    /* 확대된 셀 스타일 */
    .zoomed-cell {
      font-size: 16px !important;
      background-color: #f0f7ff !important;
      border: 2px solid #1a237e !important;
      z-index: 10;
      position: relative;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      padding: 10px !important;
      line-height: 1.5 !important;
      white-space: normal !important; /* 한 줄로 표시하지 않고 기존 상태 유지 */
      overflow: visible !important; /* 내용이 넘치도록 설정 */
      max-width: none !important; /* 최대 너비 제한 해제 */
      width: auto !important; /* 자동 너비 설정 */
      height: auto !important; /* 높이 자동 조정 */
    }
    /* 확대된 셀을 포함하는 행 스타일 */
    tr:has(.zoomed-cell) {
      position: relative;
      z-index: 100;
      height: auto !important; /* 행 높이 유지 */
    }
    
    /* 확대된 셀을 포함하는 테이블 스타일 */
    #table-container:has(.zoomed-cell) {
      overflow: visible !important;
    }
    
    /* 확대된 셀 팝업 스타일 */
    .note-popup {
      position: fixed;
      background-color: #ffffff;
      border: 2px solid #1a237e;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.3);
      z-index: 1000;
      max-width: 90%;
      max-height: 240px;
      overflow-y: auto;
      font-size: 19px;
      line-height: 1.6;
      white-space: nowrap;
      word-break: keep-all;
      overflow-x: auto;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #1a237e;
      font-weight: 500;
    }
    /* 버블 선택 시 열 너비 조정 */
    .node.selected ~ #table-container th:nth-child(1),
    .node.selected ~ #table-container td:nth-child(1) { width: 6%; }  /* 월 */
    .node.selected ~ #table-container th:nth-child(2),
    .node.selected ~ #table-container td:nth-child(2) { width: 9%; } /* 작업유형 */
    .node.selected ~ #table-container th:nth-child(3),
    .node.selected ~ #table-container td:nth-child(3) { width: 22%; } /* 절감항목 */
    .node.selected ~ #table-container th:nth-child(4),
    .node.selected ~ #table-container td:nth-child(4) { width: 8%; } /* A.집행비 */
    .node.selected ~ #table-container th:nth-child(5),
    .node.selected ~ #table-container td:nth-child(5) { width: 8%; } /* B.공사비 적용시 */
    .node.selected ~ #table-container th:nth-child(6),
    .node.selected ~ #table-container td:nth-child(6) { width: 7%; } /* 절감비(A-B) */
    .node.selected ~ #table-container th:nth-child(7),
    .node.selected ~ #table-container td:nth-child(7) { width: 40%; } /* 비고 - 더 넓게 설정 */
    /* 절감 항목 열 스타일 */
    th:nth-child(3), td:nth-child(3) {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* 절감 항목 열 호버 시 전체 텍스트 표시 */
    td:nth-child(3):hover {
      white-space: normal;
      overflow: visible;
      position: relative;
      z-index: 5;
      background-color: #f8f9fa;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    
    /* 버블 선택 시 절감 항목 열 스타일 */
    .node.selected ~ #table-container th:nth-child(3),
    .node.selected ~ #table-container td:nth-child(3) {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* B.공사비 적용시 헤더 스타일 - 문자열만 줄바꿈 */
    th:nth-child(5) {
      white-space: normal;
      word-wrap: break-word;
      word-break: break-word;
      line-height: 1.2;
    }
  </style>
</head>
<body>
  <h1>2025년 상반기 유형별 절감 현황 대시보드</h1>
  <div id="controls">
    <input type="file" id="file-input" accept=".csv">
  </div>
  <div id="select-all-container">
    <label id="select-all-checkbox">
      <input type="checkbox" id="select-all">
      전체 버블 선택/해제
    </label>
  </div>
  <div id="month-filter-container">
    <div id="month-checkboxes"></div>
  </div>
  <div id="preprocessing-log" style="position: fixed; top: 70px; left: 20px; background: white; padding: 10px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); max-width: 300px; max-height: 200px; overflow-y: auto; font-size: 11px; display: none; z-index: 1001; border-left: 4px solid #1a237e;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
      <h3 style="margin: 0; font-size: 13px; color: #1a237e; font-weight: bold;">데이터 전처리 로그</h3>
      <button id="close-log" style="background: none; border: none; color: #1a237e; font-size: 16px; cursor: pointer; padding: 0 5px;">×</button>
    </div>
    <div id="preprocessing-steps"></div>
  </div>
  <p id="message">CSV 파일을 선택해주세요.</p>
  <div id="dashboard-container">
    <svg id="chart"></svg>
    <div id="table-container">
      <table>
        <thead>
          <tr><th>월</th><th>작업유형</th><th>절감항목</th><th>A.집행비</th><th>B.공사비 적용시</th><th>절감비(A-B)</th><th>비고</th></tr>
        </thead>
        <tbody>
          <tr class="sticky-total-row"><td colspan="6">총 절감합계</td><td id="total-top">-</td></tr>
        </tbody>
      </table>
    </div>
  </div>
  <script>
    let svg = null;
    let width = 0;
    let height = 0;
    const margin = 10;
    let allData = [];
    let selectedTypes = new Set();
    let selectedMonths = new Set();
    let colorScale = null;

    // 전처리 로그 관련 전역 변수
    let preprocessingLog = null;
    let preprocessingSteps = null;

    // 전처리 로그 초기화 함수
    function initPreprocessingLog() {
      preprocessingLog = document.getElementById('preprocessing-log');
      preprocessingSteps = document.getElementById('preprocessing-steps');
      preprocessingLog.style.display = 'block';
      preprocessingSteps.innerHTML = '';
    }

    // 전처리 단계 추가 함수
    function addPreprocessingStep(step) {
      if (!preprocessingSteps) {
        initPreprocessingLog();
      }
      const stepElement = document.createElement('div');
      stepElement.style.marginBottom = '4px';
      stepElement.style.padding = '3px 6px';
      stepElement.style.backgroundColor = '#f8f9fa';
      stepElement.style.borderRadius = '3px';
      stepElement.style.borderLeft = '2px solid #e0e0e0';
      stepElement.innerHTML = step;
      preprocessingSteps.appendChild(stepElement);
      
      // 로그 창이 항상 보이도록 스크롤
      preprocessingSteps.scrollTop = preprocessingSteps.scrollHeight;
    }

    function formatMonth(month) {
      return month.replace('월', '월');
    }

    function updateMonthFilter() {
      const monthCheckboxes = document.getElementById('month-checkboxes');
      const months = [...new Set(allData.map(d => d.month))].sort();
      
      monthCheckboxes.innerHTML = months.map(m => `
        <label class="month-checkbox ${selectedMonths.has(m) ? 'selected' : ''}">
          <input type="checkbox" value="${m}" ${selectedMonths.has(m) ? 'checked' : ''}>
          ${formatMonth(m)}
        </label>
      `).join('');

      // 체크박스 이벤트 리스너 추가
      monthCheckboxes.querySelectorAll('.month-checkbox').forEach(checkbox => {
        checkbox.addEventListener('click', function() {
          const month = this.querySelector('input').value;
          if (selectedMonths.has(month)) {
            selectedMonths.delete(month);
            this.classList.remove('selected');
          } else {
            selectedMonths.add(month);
            this.classList.add('selected');
          }
          updateTable();
          updateBubbleOpacity();
        });
      });
    }

    function updateBubbleOpacity() {
      svg.selectAll('.node').each(function(d) {
        const node = d3.select(this);
        const month = d.data.month;
        const isSelected = selectedMonths.size === 0 || selectedMonths.has(month);
        const isTypeSelected = selectedTypes.has(d.data.type);
        
        if (isTypeSelected) {
          node.style('opacity', 1);
          node.select('circle')
            .attr('stroke', '#000000')
            .attr('stroke-width', 4);
          node.select('text').style('opacity', 1);
        } else {
          node.style('opacity', isSelected ? 0.5 : 0.3);
          node.select('circle')
            .attr('stroke', '#cccccc')
            .attr('stroke-width', 2);
          node.select('text').style('opacity', isSelected ? 0.5 : 0.3);
        }
      });
    }

    function initChart() {
      const chartContainer = document.getElementById('chart');
      const containerWidth = chartContainer.clientWidth;
      const containerHeight = chartContainer.clientHeight;
      width = Math.min(containerWidth, containerHeight);
      height = width; // 정사각형 유지
      
      // 화면 크기에 따라 폰트 크기 조정
      const baseFontSize = Math.min(16, width / 20);
      
      svg = d3.select('#chart')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');

      // 버블 내 텍스트 크기 조정을 위한 전역 변수 설정
      window.chartFontSize = baseFontSize;
    }

    function drawChart() {
      if (!svg) initChart();
      svg.selectAll('*').remove();
      
      // 작업유형별 데이터 그룹화 로직 개선
      const packData = d3.rollups(allData,
        v => {
          // 유효한 데이터만 필터링
          const validData = v.filter(d => d.month && d.type && d.detail);
          return {
            value: d3.sum(validData, d => Math.abs(d.saving)) || 1, // 최소값 1로 설정
            total: d3.sum(validData, d => d.saving) || 0,
            months: [...new Set(validData.map(d => d.month))],
            count: validData.length
          };
        },
        d => d.type
      ).map(([type, stats]) => ({ type, ...stats }));

      // 작업유형별 데이터 검증 로깅
      packData.forEach(d => {
        addPreprocessingStep(`버블 차트 - 작업유형 "${d.type}": 값=${d.value}, 건수=${d.count}`);
      });

      const sizeScale = 0.85;
      
      const pack = d3.pack()
        .size([(width - margin*2) * sizeScale, (height - margin*2) * sizeScale])
        .padding(8);

      const root = pack(d3.hierarchy({ children: packData }).sum(d => d.value));
      colorScale = d3.scaleOrdinal().domain(packData.map(d=>d.type)).range(d3.schemeTableau10);
      
      // 전체 선택 체크박스 상태 업데이트
      document.getElementById('select-all').checked = selectedTypes.size === packData.length;
      
      const bubbleHeight = d3.max(root.leaves(), d => d.y + d.r) - d3.min(root.leaves(), d => d.y - d.r);
      const offsetY = (height - bubbleHeight) / 2 - d3.min(root.leaves(), d => d.y - d.r);
      
      // 버블 묶음을 최대한 왼쪽으로 이동
      const offsetX = margin + 5; // 왼쪽 여백 최소화

      const nodes = svg.selectAll('g.node').data(root.leaves(), d=>d.data.type).enter().append('g')
        .attr('class', d => `node ${selectedTypes.has(d.data.type) ? 'selected' : ''}`)
        .attr('transform', d=>`translate(${d.x + offsetX},${d.y + offsetY + margin})`)
        .on('click', function(event, d) {
          event.preventDefault();
          event.stopPropagation();
          
          if (event.ctrlKey || event.metaKey) {
            // Ctrl/Cmd 키를 누른 상태에서 클릭하면 다중 선택
            if (selectedTypes.has(d.data.type)) {
              selectedTypes.delete(d.data.type);
              d3.select(this).classed('selected', false);
            } else {
              selectedTypes.add(d.data.type);
              d3.select(this).classed('selected', true);
            }
          } else {
            // 일반 클릭은 단일 선택
            if (selectedTypes.has(d.data.type)) {
              selectedTypes.clear();
              d3.select(this).classed('selected', false);
            } else {
              selectedTypes.clear();
              selectedTypes.add(d.data.type);
              svg.selectAll('.node').classed('selected', false);
              d3.select(this).classed('selected', true);
            }
          }

          // 전체 선택 체크박스 상태 업데이트
          document.getElementById('select-all').checked = selectedTypes.size === packData.length;

          // 선택된 버블들의 월 정보 업데이트
          const selectedMonthsSet = new Set();
          selectedTypes.forEach(type => {
            const bubble = packData.find(b => b.type === type);
            if (bubble) {
              bubble.months.forEach(month => selectedMonthsSet.add(month));
            }
          });
          selectedMonths = selectedMonthsSet;

          updateMonthFilter();
          updateTable();
          updateBubbleOpacity();
        });

      nodes.append('circle')
        .attr('r', d=>d.r)
        .attr('fill', d=>colorScale(d.data.type))
        .attr('stroke', d=> selectedTypes.has(d.data.type) ? '#000000' : '#cccccc')
        .attr('stroke-width', d=> selectedTypes.has(d.data.type) ? 4 : 2)
        .style('opacity', d => selectedTypes.has(d.data.type) ? 1 : 0.5);

      nodes.append('text')
        .attr('text-anchor','middle')
        .attr('dominant-baseline','middle')
        .style('fill', d=> {
          const c = d3.color(colorScale(d.data.type)).rgb();
          return (0.299*c.r + 0.587*c.g + 0.114*c.b) > 150 ? '#2c3e50' : '#fff';
        })
        .style('opacity', d => selectedTypes.has(d.data.type) ? 1 : 0.5)
        .each(function(d) {
          const t = d3.select(this);
          t.text('');
          
          const typeText = d.data.type;
          const typeWords = typeText.split(' ');
          let currentLine = '';
          let lines = [];
          
          // 버블 크기에 맞춰 텍스트 크기 조정
          const maxTextWidth = d.r * 1.8; // 버블 반지름의 1.8배를 최대 텍스트 너비로 설정
          const fontSize = Math.min(window.chartFontSize, d.r / 3);
          
          typeWords.forEach(word => {
            if ((currentLine + word).length * fontSize / 2 > maxTextWidth) {
              lines.push(currentLine.trim());
              currentLine = word;
            } else {
              currentLine += (currentLine ? ' ' : '') + word;
            }
          });
          if (currentLine) lines.push(currentLine.trim());
          
          // 텍스트 줄 수에 따라 수직 위치 조정
          const lineHeight = fontSize * 1.2;
          
          // 금액 표시
          const amountText = d3.format(',')(d.data.total);
          const amountFontSize = Math.min(fontSize, d.r / 4);
          
          // 행 개수 표시 (건)
          const countText = `${d.data.count}건`;
          const countFontSize = Math.min(amountFontSize, d.r / 5);
          
          // 전체 텍스트 높이 계산
          const totalTextHeight = lines.length * lineHeight + lineHeight * 1.5 + lineHeight * 1.2;
          
          // 시작 위치 계산 (중앙 정렬)
          const startY = -totalTextHeight / 2 + lineHeight / 2;
          
          // 작업 유형 이름 표시
          lines.forEach((line, i) => {
            t.append('tspan')
              .attr('x', 0)
              .attr('dy', i === 0 ? startY + 'px' : lineHeight + 'px')
              .text(line)
              .style('font-size', fontSize + 'px');
          });
          
          // 작업 유형 이름과 절감 금액 사이의 간격
          const typeToAmountGap = lineHeight * 1.5; // 간격 증가
          
          // 금액 표시
          t.append('tspan')
            .attr('x', 0)
            .attr('dy', typeToAmountGap + 'px') // 간격 적용
            .text(amountText)
            .style('font-size', amountFontSize + 'px');
            
          // 절감 금액과 행 개수 사이의 간격
          const amountToCountGap = lineHeight * 1.2; // 간격 증가
          
          // 행 개수 표시 (건)
          t.append('tspan')
            .attr('x', 0)
            .attr('dy', amountToCountGap + 'px') // 간격 적용
            .text(countText)
            .style('font-size', countFontSize + 'px');
            
          t.style('font-weight', selectedTypes.has(d.data.type) ? 'bold' : 'normal');
        });
    }

    // 화면 크기 변경 시 차트 다시 그리기
    window.addEventListener('resize', function() {
      if (allData.length > 0) {
        initChart();
        drawChart();
      }
    });

    document.getElementById('file-input').addEventListener('change', function(e) {
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      
      // 전처리 로그 초기화
      initPreprocessingLog();
      
      reader.onload = function(ev) {
        try {
          addPreprocessingStep('CSV 파일 파싱 중...');
          const rawData = d3.csvParse(ev.target.result);
          
          if (!rawData || !rawData.length) {
            addPreprocessingStep('오류: CSV 파일을 분석할 수 없습니다.');
            document.getElementById('message').textContent = 'CSV 파일을 분석할 수 없습니다.';
            return;
          }
          
          addPreprocessingStep(`총 ${rawData.length}개 행 파싱 완료`);
          
          // 데이터 검증 및 전처리
          let validRows = 0;
          let invalidRows = 0;
          let totalSaving = 0;
          let maxSaving = 0;
          let minSaving = 0;
          
          allData = rawData.map((d, index) => {
            // 필수 필드 검증 및 로깅
            const month = d['월'] || '';
            const type = d['작업유형'] || '';
            const detail = d['절감항목'] || '';
            const note = d['비고'] || '';
            
            // 숫자 데이터 변환 및 검증 (쉼표 제거 후 숫자 변환)
            const actual = parseFloat((d['A.집행비'] || '0').replace(/,/g, '')) || 0;
            const estimated = parseFloat((d['B.공사비 적용시'] || '0').replace(/,/g, '')) || 0;
            const saving = parseFloat((d['절감비(A-B)'] || '0').replace(/,/g, '')) || 0;
            
            // 데이터 검증 및 로깅
            if (!month || !type || !detail) {
              invalidRows++;
              addPreprocessingStep(`경고: 행 ${index + 1} - 필수 데이터 누락 (월: ${month}, 유형: ${type}, 항목: ${detail})`);
            } else {
              validRows++;
              totalSaving += saving;
              maxSaving = Math.max(maxSaving, saving);
              minSaving = Math.min(minSaving, saving);
            }
            
            return {
              month: month, 
              type: type, 
              detail: detail,
              actual: actual, 
              estimated: estimated, 
              saving: saving,
              note: note
            };
          });
          
          // 작업유형별 데이터 검증
          const typeGroups = d3.group(allData, d => d.type);
          typeGroups.forEach((rows, type) => {
            const validTypeRows = rows.filter(r => r.month && r.type && r.detail).length;
            if (validTypeRows === 0) {
              addPreprocessingStep(`경고: 작업유형 "${type}"에 유효한 데이터가 없습니다.`);
            } else {
              addPreprocessingStep(`작업유형 "${type}": ${validTypeRows}개 유효한 데이터`);
            }
          });
          
          // 전처리 결과 로깅
          addPreprocessingStep(`유효한 데이터: ${validRows}개 행`);
          if (invalidRows > 0) {
            addPreprocessingStep(`경고: ${invalidRows}개 행에 필수 데이터 누락`);
          }
          
          // 숫자 데이터에서 쉼표 제거 처리 완료 로깅
          addPreprocessingStep('숫자 데이터에서 쉼표(,) 제거 처리 완료');
          
          // 절감 금액 통계
          addPreprocessingStep(`총 절감 금액: ${d3.format(',')(totalSaving)}원`);
          addPreprocessingStep(`최대 절감: ${d3.format(',')(maxSaving)}원`);
          addPreprocessingStep(`최소 절감: ${d3.format(',')(minSaving)}원`);
          
          // 작업 유형 분석
          const typeCount = d3.rollups(allData, v => v.length, d => d.type);
          addPreprocessingStep(`작업 유형: ${typeCount.length}개`);
          
          // 월별 분석
          const monthCount = d3.rollups(allData, v => v.length, d => d.month);
          addPreprocessingStep(`월별 데이터: ${monthCount.length}개월`);
          
          // 데이터 정규화 (월 형식 통일)
          allData = allData.map(d => {
            // 월 형식 통일 (YYYY-MM-DD -> YYYY-MM)
            const monthMatch = d.month.match(/(\d{4})-(\d{2})/);
            if (monthMatch) {
              d.month = `${monthMatch[1]}-${monthMatch[2]}`;
            }
            return d;
          });
          
          addPreprocessingStep('월 형식 정규화 완료');
          
          // 중복 데이터 검사
          const duplicates = findDuplicates(allData);
          if (duplicates.length > 0) {
            addPreprocessingStep(`경고: ${duplicates.length}개 중복 데이터 발견`);
          }
          
          // 데이터 정렬 (월별, 유형별)
          allData.sort((a, b) => {
            if (a.month !== b.month) return a.month.localeCompare(b.month);
            return a.type.localeCompare(b.type);
          });
          
          addPreprocessingStep('데이터 정렬 완료');
          
          // 버블 차트 생성 전 최종 데이터 검증
          const finalTypeGroups = d3.group(allData, d => d.type);
          const missingTypes = [];
          finalTypeGroups.forEach((rows, type) => {
            if (rows.length === 0) {
              missingTypes.push(type);
            }
          });
          
          if (missingTypes.length > 0) {
            addPreprocessingStep(`경고: 다음 작업유형이 차트에 반영되지 않습니다: ${missingTypes.join(', ')}`);
          }
          
          // 전처리 완료 메시지
          addPreprocessingStep('전처리 완료! 차트 생성 중...');
          
          selectedMonths = new Set();
          updateMonthFilter();
          
          document.getElementById('message').textContent = '파일이 성공적으로 로드되었습니다.';
          selectedTypes = new Set();
          initChart();
          drawChart(); 
          updateTable();
          
          // 2초 후 전처리 로그 숨기기
          setTimeout(() => {
            preprocessingLog.style.display = 'none';
          }, 2000);
          
          // 로그 닫기 버튼 이벤트 리스너 추가
          document.getElementById('close-log').addEventListener('click', function() {
            preprocessingLog.style.display = 'none';
          });
          
        } catch (error) {
          addPreprocessingStep(`오류 발생: ${error.message}`);
          document.getElementById('message').textContent = '파일 처리 중 오류가 발생했습니다.';
        }
      };
      
      // 중복 데이터 찾기 함수
      function findDuplicates(data) {
        const seen = new Map();
        const duplicates = [];
        
        data.forEach((item, index) => {
          const key = `${item.month}-${item.type}-${item.detail}`;
          if (seen.has(key)) {
            duplicates.push({index, key, original: seen.get(key)});
          } else {
            seen.set(key, index);
          }
        });
        
        return duplicates;
      }
      
      reader.readAsText(file);
    });

    function updateTable() {
      const tbody = document.querySelector('tbody');
      const totalRow = document.querySelector('.sticky-total-row');
      tbody.innerHTML = '';
      tbody.appendChild(totalRow);

      // 월 필터 적용
      let filtered = allData.filter(d => selectedTypes.has(d.type));
      if (selectedMonths.size > 0) {
        filtered = filtered.filter(d => selectedMonths.has(d.month));
      }
      
      // 유형별로 그룹화
      const typeGroups = d3.group(filtered, d => d.type);
      let totalSum = 0;

      // 비고 열의 최대 너비를 계산하기 위한 변수
      let maxNoteWidth = 0;
      let maxNoteText = '';
      
      // 절감 항목 열의 최대 너비를 계산하기 위한 변수
      let maxDetailWidth = 0;
      let maxDetailText = '';
      
      // 먼저 모든 비고 텍스트와 절감 항목 텍스트의 길이를 확인
      typeGroups.forEach((rows, type) => {
        rows.forEach(row => {
          // 비고 텍스트 길이 확인
          if (row.note && row.note.length > maxNoteText.length) {
            maxNoteText = row.note;
            maxNoteWidth = Math.max(maxNoteWidth, row.note.length * 8);
          }
          
          // 절감 항목 텍스트 길이 확인
          if (row.detail && row.detail.length > maxDetailText.length) {
            maxDetailText = row.detail;
            maxDetailWidth = Math.max(maxDetailWidth, row.detail.length * 8);
          }
        });
      });
      
      // 비고 열의 너비를 동적으로 조정 (더 넓게 설정)
      const tableContainer = document.getElementById('table-container');
      const tableWidth = tableContainer.clientWidth;
      
      // 버블 선택 여부에 따라 비고 열 너비 조정
      let noteColumnWidth;
      if (selectedTypes.size === 1) {
        // 단일 버블 선택 시 비고 열 너비를 더 넓게 설정
        noteColumnWidth = Math.min(Math.max(maxNoteWidth + 20, tableWidth * 0.4), tableWidth * 0.5);
      } else {
        // 기본 비고 열 너비
        noteColumnWidth = Math.min(Math.max(maxNoteWidth + 20, tableWidth * 0.35), tableWidth * 0.45);
      }
      
      // 절감 항목 열 너비 계산
      let detailColumnWidth;
      if (selectedTypes.size === 1) {
        // 단일 버블 선택 시 절감 항목 열 너비를 텍스트 길이에 맞게 설정
        detailColumnWidth = Math.min(Math.max(maxDetailWidth + 20, tableWidth * 0.22), tableWidth * 0.3);
      } else {
        // 기본 절감 항목 열 너비
        detailColumnWidth = Math.min(Math.max(maxDetailWidth + 20, tableWidth * 0.18), tableWidth * 0.25);
      }
      
      // 열 너비를 동적으로 설정
      const style = document.createElement('style');
      style.textContent = `
        @media (min-width: 1200px) {
          th:nth-child(7), td:nth-child(7) { 
            width: ${noteColumnWidth}px !important; 
            max-width: ${noteColumnWidth}px !important;
          }
          th:nth-child(3), td:nth-child(3) {
            width: ${detailColumnWidth}px !important;
            max-width: ${detailColumnWidth}px !important;
          }
        }
      `;
      document.head.appendChild(style);

      // B.공사비 적용시 헤더 스타일 적용 - "B.공사비" 이후 줄바꿈
      const bHeader = document.querySelector('th:nth-child(5)');
      if (bHeader) {
        // 기존 내용 가져오기
        const originalText = bHeader.textContent;
        
        // "B.공사비" 이후 줄바꿈 적용
        if (originalText.includes('B.공사비 적용시')) {
          bHeader.innerHTML = 'B.공사비<br>적용시';
        }
        
        // 스타일 적용
        bHeader.style.whiteSpace = 'normal';
        bHeader.style.wordWrap = 'break-word';
        bHeader.style.wordBreak = 'break-word';
        bHeader.style.lineHeight = '1.2';
      }

      typeGroups.forEach((rows, type) => {
        // 각 행 추가
        rows.forEach(row => {
          const tr = document.createElement('tr');
          ['month','type','detail','actual','estimated','saving','note'].forEach(key => {
            const td = document.createElement('td');
            let val = row[key];
            if (['actual','estimated','saving'].includes(key)) {
              if (val === 0) td.textContent = '-';
              else {
                td.textContent = d3.format(',')(val);
                if (val < 0) td.style.color = 'red';
              }
            } else if (key === 'month') {
              td.textContent = formatMonth(val);
            } else if (key === 'note') {
              // 비고 열의 텍스트 처리
              td.textContent = val;
              td.style.textAlign = 'center';
              td.style.paddingLeft = '10px';
              td.style.whiteSpace = 'normal';
              td.style.wordBreak = 'break-word';
              
              // 버블 선택 시 비고 텍스트 크기 조정
              if (selectedTypes.size === 1) {
                td.style.fontSize = '11px';
                td.style.lineHeight = '1.3';
              }
              
              // 비고 셀에 클릭 이벤트 추가
              td.addEventListener('click', function(e) {
                e.stopPropagation(); // 이벤트 버블링 방지
                
                // 현재 확대된 셀 확인
                const currentlyZoomed = document.querySelector('.zoomed-cell');
                if (currentlyZoomed && currentlyZoomed !== this) {
                  // 다른 셀이 확대되어 있으면 축소
                  currentlyZoomed.classList.remove('zoomed-cell');
                  
                  // 기존 팝업 제거
                  const existingPopup = document.querySelector('.note-popup');
                  if (existingPopup) {
                    existingPopup.remove();
                  }
                }
                
                // 클릭한 셀 토글
                this.classList.toggle('zoomed-cell');
                
                // 확대 상태일 때 팝업 표시
                if (this.classList.contains('zoomed-cell')) {
                  // 팝업 생성
                  const popup = document.createElement('div');
                  popup.className = 'note-popup';
                  popup.textContent = val;
                  
                  // 팝업 추가
                  document.body.appendChild(popup);
                  
                  // 팝업 닫기 버튼 추가
                  const closeBtn = document.createElement('button');
                  closeBtn.textContent = '×';
                  closeBtn.style.position = 'absolute';
                  closeBtn.style.right = '5px';
                  closeBtn.style.top = '5px';
                  closeBtn.style.background = 'none';
                  closeBtn.style.border = 'none';
                  closeBtn.style.fontSize = '22px';
                  closeBtn.style.cursor = 'pointer';
                  closeBtn.style.color = '#1a237e';
                  closeBtn.onclick = function(e) {
                    e.stopPropagation();
                    popup.remove();
                    td.classList.remove('zoomed-cell');
                  };
                  popup.appendChild(closeBtn);
                  
                  // 팝업 외부 클릭 시 닫기
                  document.addEventListener('click', function closePopup(e) {
                    if (!popup.contains(e.target) && e.target !== td) {
                      popup.remove();
                      td.classList.remove('zoomed-cell');
                      document.removeEventListener('click', closePopup);
                    }
                  });
                } else {
                  // 축소 상태일 때 팝업 제거
                  const popup = document.querySelector('.note-popup');
                  if (popup) {
                    popup.remove();
                  }
                }
              });
            } else if (key === 'detail') {
              // 절감 항목 열의 텍스트 처리
              td.textContent = val;
              td.title = val; // 툴크 추가
              
              // 버블 선택 시 절감 항목 텍스트 스타일 조정
              if (selectedTypes.size === 1) {
                td.style.whiteSpace = 'nowrap';
                td.style.overflow = 'hidden';
                td.style.textOverflow = 'ellipsis';
              }
              
              // 절감 항목 셀에 호버 이벤트 추가
              td.addEventListener('mouseenter', function() {
                this.style.whiteSpace = 'normal';
                this.style.overflow = 'visible';
                this.style.position = 'relative';
                this.style.zIndex = '5';
                this.style.backgroundColor = '#f8f9fa';
                this.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
              });
              
              td.addEventListener('mouseleave', function() {
                this.style.whiteSpace = 'nowrap';
                this.style.overflow = 'hidden';
                this.style.position = 'static';
                this.style.zIndex = 'auto';
                this.style.backgroundColor = '';
                this.style.boxShadow = 'none';
              });
            } else {
              td.textContent = val;
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });

        // 유형별 소계 추가
        const subtotal = rows.reduce((sum, r) => sum + r.saving, 0);
        totalSum += subtotal;
        const trSub = document.createElement('tr');
        trSub.className = 'subtotal';
        
        // Get the color for this type from the color scale
        const typeColor = colorScale(type);
        
        const tdL = document.createElement('td');
        tdL.colSpan = 5; // 소계 텍스트 셀
        tdL.textContent = `${type} 소계`;
        tdL.style.color = typeColor;
        
        const tdV = document.createElement('td');
        if (subtotal === 0) tdV.textContent = '-';
        else {
          tdV.textContent = d3.format(',')(subtotal);
          tdV.style.color = typeColor;
        }

        const tdEmpty = document.createElement('td');
        tdEmpty.colSpan = 1; // 빈 셀 추가
        
        trSub.appendChild(tdL);
        trSub.appendChild(tdV);
        trSub.appendChild(tdEmpty); // 빈 셀 추가
        tbody.appendChild(trSub);
      });

      // 총계 업데이트
      const totalTop = document.getElementById('total-top');
      if (totalSum === 0) totalTop.textContent = '-';
      else {
        totalTop.textContent = d3.format(',')(totalSum);
        if (totalSum < 0) totalTop.style.color = 'red';
      }
    }

    // 전체 선택 체크박스 이벤트 리스너
    document.getElementById('select-all').addEventListener('change', function(e) {
      const allTypes = new Set(allData.map(d => d.type));
      if (e.target.checked) {
        // 전체 선택
        selectedTypes = new Set(allTypes);
        // 모든 월도 선택
        selectedMonths = new Set(allData.map(d => d.month));
      } else {
        // 전체 해제
        selectedTypes.clear();
        selectedMonths.clear();
      }
      
      // 버블 선택 상태 업데이트
      svg.selectAll('.node')
        .classed('selected', d => selectedTypes.has(d.data.type))
        .select('circle')
        .attr('stroke', d => selectedTypes.has(d.data.type) ? '#000000' : '#cccccc')
        .attr('stroke-width', d => selectedTypes.has(d.data.type) ? 4 : 2)
        .style('opacity', d => selectedTypes.has(d.data.type) ? 1 : 0.5);

      updateMonthFilter();
      updateTable();
      updateBubbleOpacity();
    });
  </script>
</body>
</html>